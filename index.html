<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Color Game</title>
  <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #0f0c29, #302b63, #24243e);
      color: white;
      padding: 15px;
      margin: 0;
      overflow-x: hidden;
    }
      .container {
          display: flex;
          gap: 15px;
          max-width: 1200px;
          margin: 0 auto;
      }
      .main-panel {
          flex: 1;
          min-width: 400px;
      }

      .sidebar {
          width: 320px;
          flex-shrink: 0;
      }
    .ball-gray { background: gray; }
    .ball-green { background: green; }
    .ball-blue { background: #2196F3; }
    .ball-purple { background: purple; }
    .ball-yellow { background: gold; color: black; }
    .ball-orange { background: orange; color: black; }

    .main-panel {
      flex: 1;
      max-width: 600px;
      /*margin-left:300px;*/
      height:100%;
    }
    .sidebar {
      width: 320px;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 12px;
      padding: 15px;
      backdrop-filter: blur(5px);
      border: 1px solid #555;
    }
    h1 {
      text-align: center;
      font-size: 28px;
      margin: 10px 0;
      color: #ffcc00;
      text-shadow: 0 0 10px rgba(255,204,0,0.7);
    }

    .score-board {
      display: flex;
      justify-content: space-between;
      margin: 15px 0;
      font-size: 20px;
      font-weight: bold;
      background: rgba(0,0,0,0.3);
      padding: 10px;
      border-radius: 8px;
    }

    .chip-btn {
      background: #3a3a5a;
      color: white;
      border: 2px solid transparent;
      padding: 6px 12px;
      margin: 0 4px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
    }
    .chip-btn.active {
      border-color: #ffeb3b;
      background: #4a4a6a;
      box-shadow: 0 0 8px rgba(255,235,59,0.6);
    }

    .color-buttons {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(2, 1fr);
      gap: 8px;
      margin: 15px 0;
      height: 120px;
    }
    .color-btn {
      border: 2px solid #ccc;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      font-size: 18px;
      text-shadow: 0 0 3px black;
      transition: transform 0.2s, box-shadow 0.2s;
      aspect-ratio: 2 / 1;
      position: relative;
    }
    .color-btn:hover { transform: scale(1.03); }
    .color-btn.bet { 
      /*transform: scale(1.05); 
      box-shadow: 0 0 10px yellow; 
      border-color: gold;*/
    }
    .color-btn[data-color="gray"] { background: gray; }
    .color-btn[data-color="green"] { background: green; }
    .color-btn[data-color="blue"] { background: #2196F3; }
    .color-btn[data-color="purple"] { background: purple; }
    .color-btn[data-color="yellow"] { background: gold; color: black; }
    .color-btn[data-color="orange"] { background: orange; color: black; }

    /* âœ… æ–°å¢ï¼šå¼€å¥–å€æ•°æ˜¾ç¤ºæ ·å¼ */
    .multiplier-text {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 48px;
      font-weight: bold;
      pointer-events: none;
    }
    .multiplier-hit {
      color: #ff5252; /* çº¢è‰² */
    }
    .multiplier-miss {
      color: #aaa; /* ç°è‰² */
    }

    .gacha-machine {
      height: 160px;
      background: linear-gradient(to bottom, #2c1a4d, #1a0f2e);
      border-radius: 12px;
      position: relative;
      overflow: hidden;
      border: 3px solid #6a4c93;
      box-shadow: 0 0 15px rgba(106, 76, 147, 0.6);
      margin: 15px 0;
    }
    .machine-label {
      position: absolute;
      top: 8px;
      left: 0;
      right: 0;
      text-align: center;
      font-size: 14px;
      color: #ddd;
      font-weight: bold;
    }
    .ball-inside {
      position: absolute;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      opacity: 0.95;
    }

    .output-tray {
      height: 50px;
      background: #111;
      border: 2px solid #555;
      border-radius: 8px;
      margin-top: 10px;
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 12px;
      position: relative;
    }
    .tray-label {
      position: absolute;
      top: -20px;
      left: 10px;
      font-size: 13px;
      color: #888;
    }
    .ball-output {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 2px solid white;
      animation: popIn 0.4s ease-out;
    }
    @keyframes popIn {
      0% { transform: scale(0); opacity: 0; }
      70% { transform: scale(1.2); }
      100% { transform: scale(1); opacity: 1; }
    }

      .action-group {
          display: flex;
          gap: 10px;
          justify-content: center;
          flex-wrap: wrap;
          margin-top: 90px !important; /* ğŸ‘ˆ å…³é”®ï¼šå›ºå®š 90px ä¸Šè¾¹è· */
      }
    .action-btn {
      background: linear-gradient(to right, #ff5722, #ff9800);
      color: white;
      border: none;
      padding: 8px 16px;
      font-size: 15px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      min-width: 90px;
    }
    .clear-btn, .stop-btn {
      background: linear-gradient(to right, #6c757d, #909da8) !important;
    }
    .auto-btn {
      background: linear-gradient(to right, #4caf50, #8bc34a) !important;
    }
    .action-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .simulation-table h3 {
      margin-top: 0;
      color: #4fc3f7;
      text-align: center;
      font-size: 18px;
    }
    .table-header, .table-row, .table-total {
      display: grid;
      grid-template-columns: 120px 80px 70px 90px;
      padding: 6px 0;
      font-size: 12px;
    }
    .table-header {
      font-weight: bold;
      border-bottom: 1px solid #444;
    }
    .table-row {
      border-bottom: 1px solid #333;
      align-items: center;
    }
    .balls-cell {
      display: flex;
      gap: 3px;
      justify-content: center;
    }
    .small-ball {
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 1px solid #aaa;
    }
    .ball-unknown {
      background: transparent !important;
      border: 1px dashed #aaa !important;
    }
    .summary-footer {
      margin-top: 15px;
      padding-top: 10px;
      border-top: 1px solid #555;
      font-size: 14px;
    }
    .expectation {
      color: #4caf50;
      font-weight: bold;
    }

    .win-cell {
      font-weight: bold;
    }
    .win-high {
      color: #4caf50;
    }
    .win-low {
      color: #f44336;
    }

    .color-stats-table {
      margin-top: 25px;
    }
    .stats-title {
      text-align: center;
      color: #bb86fc;
      font-size: 16px;
      margin-bottom: 10px;
    }
    .stats-header, .stats-row {
      display: grid;
      grid-template-columns: 70px 80px 100px;
      padding: 6px 0;
      font-size: 13px;
    }
    .stats-header {
      font-weight: bold;
      border-bottom: 1px solid #444;
    }
    .stats-row {
      border-bottom: 1px solid #333;
      align-items: center;
    }
    .color-cell {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .color-name {
      font-size: 12px;
    }
      /* è®© credit æ•°å­—å˜åŒ–æ—¶æœ‰æ·¡å…¥æ•ˆæœ */
      #credit-display {
          transition: opacity 0.2s;
      }

      /* è‰²å—ç›¸å¯¹å®šä½ï¼ˆè®©å³ä¸Šè§’å…ƒç´ èƒ½ absolute å®šä½ï¼‰ */
      .color-btn {
          position: relative;
      }

      /* æŠ¼æ³¨é‡‘é¢æ ·å¼ï¼ˆå±…ä¸­æ˜¾ç¤ºï¼‰ */
      .bet-amount {
          display: block;
          text-align: center;
          font-size: 20px;
          color: black;
          margin-top: 4px;
          text-shadow: none; /* æ˜ç¡®å…³é—­é˜´å½± */
          -webkit-font-smoothing: antialiased; /* å¯é€‰ï¼šè®©å­—ä½“æ›´æ¸…æ™° */
      }

      /* å€æ•°æç¤ºï¼šå›ºå®šåœ¨å³ä¸Šè§’ */
      .multiplier-hint {
          position: absolute;
          top: 4px;
          right: 4px;
          font-size: 30px;
          font-weight:700;
          color: red;
          text-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
      }

      /* æœªä¸­å¥–è‰²å—ï¼šä½äº® + ç°åº¦ */
      .color-btn.dimmed {
          opacity: 0.4;
      }
      .score-board {
          display: flex;
          justify-content: space-between;
          gap: 16px;
          margin: 12px 0;
          font-family: 'Courier New', monospace; /* æ•°å­—å¯¹é½æ›´å¥½ */
      }

      .display-panel {
          flex: 1;
          background: #0a0a14;
          border: 2px solid #2c2c44;
          border-radius: 8px;
          padding: 10px;
          text-align: center;
          box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.7), 0 0 4px rgba(0, 100, 255, 0.3);
          min-width: 120px;
      }

          .display-panel .label {
              font-size: 12px;
              color: #aaa;
              letter-spacing: 1px;
              text-transform: uppercase;
              margin-bottom: 4px;
          }

          .display-panel .value {
              font-size: 18px;
              font-weight: bold;
              color: #4dff4d; /* è§å…‰ç»¿ï¼Œç»å…¸è¡—æœºè‰² */
              text-shadow: 0 0 6px rgba(77, 255, 77, 0.6);
              line-height: 1.2;
          }

      /* å¯é€‰ï¼šWIN å’Œ CREDIT ç”¨ä¸åŒé«˜äº®è‰² */
      .win-panel .value {
          color: #ffcc00; /* é‡‘è‰² */
          text-shadow: 0 0 6px rgba(255, 204, 0, 0.6);
      }

      .credit-panel .value {
          color: #4dff4d; /* è§å…‰ç»¿ */
          text-shadow: 0 0 6px rgba(77, 255, 77, 0.6);
      }

      .gacha-machine {
          position: relative;
          width: 200px; /* æˆ–è€…ä»»ä½•ä½ å¸Œæœ›çš„å°ºå¯¸ */
          height: 200px;
          background: #0f0f23;
          border-radius: 50%; /* å°†å®¹å™¨å˜æˆåœ†å½¢ */
          overflow: hidden;
          margin: 16px auto;
          border: 3px solid #444;
          box-shadow: inset 0 0 12px rgba(0,0,0,0.8);
      }

      .ball-inside {
          position: absolute;
          width: 40px;
          height: 40px;
          border-radius: 50%;
          transform: translate(-50%, -50%); /* ä»¥ä¸­å¿ƒå®šä½ */
      }
      .credit-panel {
          position: relative;
      }

      .add-credit-btn {
          position: absolute;
          top: 4px;
          right: 4px;
          width: 20px;
          height: 20px;
          font-size: 14px;
          line-height: 1;
          background: #4caf50;
          color: white;
          border: none;
          border-radius: 50%;
          cursor: pointer;
          padding: 0;
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 10;
      }

          .add-credit-btn:hover {
              background: #45a049;
          }
  </style>
</head>
<body>
  <div id="app" class="container">
      <div class="sidebar">
          <div class="simulation-table" v-if="martingaleResult && !martingaleResult.error">
              <h3>å€æŠ•ç­–ç•¥æ¨¡æ‹Ÿç»“æœ</h3>

              <!-- è¡¨å¤´ï¼š5åˆ—ï¼Œå‹ç¼©å®½åº¦ -->
              <div class="table-header" style="grid-template-columns: 0.6fr 1fr 1fr 1fr 1.1fr;">
                  <div>å‘¨æœŸ</div>
                  <div>æ€»æŠ¼æ³¨</div>
                  <div>ä¸­å¥–</div>
                  <div>å‡€åˆ©æ¶¦</div>
                  <div>ç»“æŸä½™é¢</div>
              </div>

              <!-- æˆåŠŸå‘¨æœŸ -->
              <div v-for="(cycle, idx) in martingaleResult.completedCycles"
                   :key="idx"
                   class="table-row"
                   style="grid-template-columns: 0.6fr 1fr 1fr 1fr 1.1fr;"
                   >
                  <div>{{ idx + 1 }}</div>
                  <div>{{ formatNumber(cycle.totalBet) }}</div>
                  <div>{{ formatNumber(cycle.totalWin) }}</div>
                  <div class="win-cell"
                       :class="cycle.netProfit >= 0 ? 'win-high' : 'win-low'">
                      {{ cycle.netProfit >= 0 ? '+' : '' }}{{ formatNumber(cycle.netProfit) }}
                  </div>
                  <div>{{ formatNumber(cycle.creditAfter) }}</div>
              </div>

              <!-- æœªå®Œæˆå‘¨æœŸï¼ˆå¤±è´¥é“¾æ±‡æ€»ï¼‰ -->
              <div v-if="martingaleResult.incompleteCycle"
                   class="table-row"
                   style="grid-template-columns: 0.6fr 1fr 1fr 1fr 1.1fr;">
                  <div>Ã—</div>
                  <div>{{ formatNumber(martingaleResult.incompleteCycle.totalBet) }}</div>
                  <div>{{ formatNumber(martingaleResult.incompleteCycle.totalWin) }}</div>
                  <div class="win-cell win-low">
                      {{ formatNumber(martingaleResult.incompleteCycle.netProfit) }}
                  </div>
                  <div>{{ formatNumber(martingaleResult.incompleteCycle.creditAfter) }}</div>
              </div>
              <!-- å¯å±•å¼€çš„è¯¦ç»†è¿è´¥è®°å½• -->
              <details v-if="martingaleResult.failedChain && martingaleResult.failedChain.length > 0"
                       style="margin-top: 4px; border: 1px solid #eee; border-radius: 4px; overflow: hidden;">
                  <summary style="
      padding: 6px 12px;
      background: #f8f9fa;
      cursor: pointer;
      font-size: 13px;
      color: #e74c3c;
      list-style: none;
    ">
                      â–¶ å±•å¼€æœ€å {{ martingaleResult.failedChain.length }} è¿è´¥è¯¦æƒ…
                  </summary>

                  <!-- è¯¦æƒ…è¡¨å¤´ -->
                  <div class="table-header" style="grid-template-columns: 0.8fr 1.2fr 1.2fr 1.5fr; padding: 4px 8px;">
                      <div>åºå·</div>
                      <div>æŠ¼æ³¨</div>
                      <div>ä¸­å¥–</div>
                      <div>ä½™é¢</div>
                  </div>

                  <!-- è¯¦æƒ…è¡Œ -->
                  <div v-for="(round, i) in martingaleResult.failedChain"
                       :key="i"
                       class="table-row"
                       style="grid-template-columns: 0.8fr 1.2fr 1.2fr 1.5fr;padding: 4px 8px; font-size: 13px;">
                      <div>{{ round.round }}</div>
                      <div>{{ formatNumber(round.bet) }}</div>
                      <div class="win-cell win-low">{{ formatNumber(round.win) }}</div>
                      <div>{{ formatNumber(round.creditAfter) }}</div>
                  </div>
              </details>

              <!-- æ±‡æ€»è¡Œ -->
              <div class="table-total"
                   style="
      font-weight: bold;
      border-top: 1px solid #666;
      margin-top: 12px;
      display: grid;
      grid-template-columns: 0.6fr 1fr 1fr 1fr 1.1fr;
    ">
                  <div>åˆè®¡</div>
                  <div>{{ formatNumber(martingaleResult.summary.totalBetAmount) }}</div>
                  <div>{{ formatNumber(martingaleResult.summary.totalWin) }}</div>
                  <div :class="martingaleResult.summary.netProfit >= 0 ? 'win-high' : 'win-low'">
                      {{ martingaleResult.summary.netProfit >= 0 ? '+' : '' }}{{ formatNumber(martingaleResult.summary.netProfit) }}
                  </div>
                  <div>{{ formatNumber(martingaleResult.finalCredit) }}</div>
              </div>

              <!-- åº•éƒ¨æ‘˜è¦ -->
              <div class="summary-footer" style="margin-top: 12px; display: flex; justify-content: space-between;">
                  <p>æˆåŠŸå‘¨æœŸ: {{ martingaleResult.completedCycles.length }}</p>
                  <p>èµ„é‡‘å³°å€¼: {{ formatNumber(martingaleResult.maxCredit) }}</p>
                  <p>æœ€ç»ˆä½™é¢: {{ formatNumber(martingaleResult.finalCredit) }}</p>
                  <p>å­¤æ³¨ä¸€æ·æ¬¡æ•°: {{martingaleResult.allInCount}}</p>
              </div>
          </div>

          <div v-else-if="martingaleResult && martingaleResult.error" class="simulation-table">
              <div style="color: #e74c3c; padding: 12px;">âš ï¸ {{ martingaleResult.error }}</div>
          </div>

      </div>
    <!-- ä¸»é¢æ¿ -->
    <div class="main-panel">
      <h1>Color Game</h1>
      <div class="gacha-machine">
          <div v-for="(ball, i) in machineBalls"
               :key="i"
               class="ball-inside"
               :class="'ball-' + ball.color"
               :style="{ left: ball.x + 'px', top: ball.y + 'px' }"></div>
      </div>
      <div class="output-tray">
        <div class="tray-label">å¼€å¥–ç»“æœ</div>
        <div v-for="(ball, i) in outputBalls" :key="i" 
             class="ball-output" :class="'ball-' + ball"></div>
      </div>

      <div v-if="0" class="score-board">
        <div>WIN-BOUNS: {{ formatNumber(win) }}</div>
        <div id="credit-display">CREDIT: {{ credit}}</div>
      </div>
      <div class="score-board">
          <div class="display-panel win-panel">
              <div class="label">WIN-BONUS</div>
              <div class="value">{{ win }}</div>
          </div>
          <div class="display-panel credit-panel">
              <div class="label">CREDIT</div>
              <!-- âœ… æ–°å¢ï¼š+ æŒ‰é’® -->
              <button class="add-credit-btn" @click.stop="addCredit(1000000)">+</button>
              <div class="value">{{ credit }}</div>
          </div>
      </div>
      <div class="bet-controls">
          <button class="chip-btn" :class="{ active: selectedChip === 1 }" @click="selectChip(1)">1</button>
          <button class="chip-btn" :class="{ active: selectedChip === 10 }" @click="selectChip(10)">10</button>
          <button class="chip-btn" :class="{ active: selectedChip === 100 }" @click="selectChip(100)">100</button>
          <button class="chip-btn" :class="{ active: selectedChip === 1000 }" @click="selectChip(1000)">1K</button>
          <button class="chip-btn" :class="{ active: selectedChip === 10000 }" @click="selectChip(10000)">10K</button>
          <button class="chip-btn" :class="{ active: selectedChip === 100000 }" @click="selectChip(100000)">100K</button>
          <button class="chip-btn" :class="{ active: selectedChip === 1000000 }" @click="selectChip(1000000)">1M</button>
      </div>

      
      <div class="color-buttons">
          <div v-for="color in colors"
               :key="color"
               class="color-btn"
               :class="{bet: bets[color] > 0,dimmed: hasResult && !isWinningColor(color)}"
              v-bind:data-color="color"
              v-on:click="placeBet(color)"
              v-bind:disabled="credit <= 0 || isSpinning || hasResult"
              >
              <!-- ğŸ’° æŠ¼æ³¨é‡‘é¢ï¼šåªè¦ >0 å°±ä¸€ç›´æ˜¾ç¤ºï¼ˆåŒ…æ‹¬å¼€å¥–åï¼‰ -->
              <span v-if="bets[color] > 0" class="bet-amount">
                  {{ formatNumber(bets[color]) }}
              </span>

              <!-- ğŸ¯ å€æ•°ï¼šä»…åœ¨å¼€å¥–åï¼ˆhasResultï¼‰æ˜¾ç¤ºåœ¨å³ä¸Šè§’ -->
              <div v-if="hasResult" class="multiplier-hint">
                  {{ multiplierText(color) }}
              </div>
          </div>
      </div>
      <div class="action-group">
          <button class="action-btn" @click="handleAction" :disabled="isDisabled">
              {{ hasResult ? 'å¾— åˆ†' : (Object.values(lastBets).some(v => v > 0) ? 'å¯ åŠ¨' : 'å¯ åŠ¨') }}
          </button>
        <button 
          v-if="totalBet > 0 && !isSpinning && !hasResult" 
          class="action-btn clear-btn" 
          @click="clearBets"
        >
          æ¸… ç©º
        </button>
        <button 
          v-if="!isAutoMode" 
          class="action-btn auto-btn" 
          @click="startAutoMode"
          :disabled="isDisabled || totalBet === 0"
        >
          è‡ª åŠ¨
        </button>
        <button 
          v-else 
          class="action-btn stop-btn" 
          @click="stopAutoMode"
        >
          åœ æ­¢
        </button>
      </div>

      <!-- æ¨¡æ‹Ÿè¿è¡Œæ§åˆ¶åŒº -->
      <div class="simulation-control" style="margin-top: 20px; text-align: center;">
          <div style="display: flex; gap: 8px; justify-content: center; align-items: center; margin-top: 10px;">
              <input type="number"
                     v-model.number="simulateCount"
                     min="1"
                     max="100000"
                     placeholder="æ¬¡æ•°"
                     style="width: 100px; padding: 6px; border-radius: 4px; border: 1px solid #666;" />
              <button class="action-btn auto-btn"
                      @click="runSimulation"
                      :disabled="isDisabled || simulateCount <= 0"
                      style="font-size: 14px; padding: 6px 12px;">
                  æ¨¡æ‹Ÿè¿è¡Œ
              </button>
              <button @click="runMartingaleSimulation" class="action-btn auto-btn" :disabled="isDisabled || simulateCount <= 0" style="font-size: 14px; padding: 6px 12px;">æ¨¡æ‹Ÿå€æŠ•ç­–ç•¥</button>
          </div>
          <!-- è¿›åº¦æç¤º -->
          <div v-if="simulateMessage" style="margin-top: 8px; font-size: 13px; color: #bbdefb;">
              {{ simulateMessage }}
          </div>
          <!-- ä»…é¢œè‰²ç»Ÿè®¡ -->
          <div v-else-if="simulationResult && simulationResult.status === 'color-only'" style="margin-top: 8px; font-size: 13px; color: #bbdefb;">
              âœ… æ¨¡æ‹Ÿå®Œæˆ {{ simulationResult.runs }} æ¬¡ï¼ä»…ç»Ÿè®¡é¢œè‰²
          </div>
          <!-- âœ… æ¨ªå‘è¡¨æ ¼ç»“æœ -->
          <div v-else-if="simulationResult && simulationResult.status" style="margin-top: 8px; font-size: 13px; color: #bbdefb;">
              <!-- æ ‡é¢˜ -->
              <div style="font-weight: bold; margin-bottom: 4px;">
                  {{
      simulationResult.status === 'completed'
        ? `âœ… æ¨¡æ‹Ÿå®Œæˆ ${simulationResult.runs} æ¬¡ï¼`
        : `âš ï¸ åˆ†æ•°ä¸è¶³ï¼Œæå‰ç»ˆæ­¢ï¼ˆ${simulationResult.runs} æ¬¡ï¼‰`
                  }}
              </div>
              <!-- æ¨ªå‘è¡¨æ ¼ï¼šä¸€è¡Œä¸‰åˆ— -->
              <div style="display: flex; gap: 12px; justify-content: flex-start; flex-wrap: wrap;">
                  <div style="background: rgba(0,0,0,0.3); padding: 4px 10px; border-radius: 4px; min-width: 100px;">
                      <div style="font-size: 11px; opacity: 0.7;">æ€»æŠ¼æ³¨</div>
                      <div>{{ formatNumber(simulationResult.totalBetAmount) }}</div>
                  </div>
                  <div style="background: rgba(0,0,0,0.3); padding: 4px 10px; border-radius: 4px; min-width: 100px;">
                      <div style="font-size: 11px; opacity: 0.7;">ä¸­å¥–åˆ†æ•°</div>
                      <div>{{ formatNumber(simulationResult.totalWin) }}</div>
                  </div>
                  <div style="background: rgba(0,0,0,0.3); padding: 4px 10px; border-radius: 4px; min-width: 100px;">
                      <div style="font-size: 11px; opacity: 0.7;">å‡€åˆ©æ¶¦</div>
                      <div :style="{ color: simulationResult.netProfit >= 0 ? '#4caf50' : '#f44336' }">
                          <span v-if="simulationResult.netProfit >= 0">+</span>
                          {{ formatNumber(simulationResult.netProfit) }}
                      </div>
                  </div>
                  <div style="background: rgba(0,0,0,0.3); padding: 4px 10px; border-radius: 4px; min-width: 100px;">
                      <div style="font-size: 11px; opacity: 0.7;">è¿”å¥–ç‡</div>
                      <div :style="{ color: simulationResult.netProfit >= 0 ? '#4caf50' : '#f44336' }">
                          <span v-if="simulationResult.netProfit >= 0">+</span>
                          {{ (simulationResult.totalWin / simulationResult.totalBetAmount * 100).toFixed(2) + "%" }}
                      </div>
                  </div>
              </div>
          </div>


      </div>
    </div>

    <!-- å³ä¾§æ±‡æ€»è¡¨ï¼ˆå§‹ç»ˆæ˜¾ç¤ºç»Ÿè®¡ï¼‰ -->
    <div class="sidebar">
        <div class="score-board">
            <div class="display-panel win-panel">
                <div class="label">æ€»ä¸­å¥–åˆ†æ•°</div>
                <div class="value">{{ formatNumber(totalWinScore) }}</div>
            </div>
            <div class="display-panel credit-panel">
                <div class="label">æ€»æŠ¼åˆ†æ•°</div>
                <div class="value">{{ formatNumber(totalBetScore) }}</div>
            </div>
        </div>
      <div class="simulation-table" v-if="showSimulation">
        <h3>å¼€å¥–å¯èƒ½æ±‡æ€»</h3>
        <div class="table-header">
          <div>å¼€å¥–ç»“æœ</div>
          <div>ç»„åˆ</div>
          <div>æ¦‚ç‡</div>
          <div>å¥–é‡‘</div>
        </div>
        <div v-for="(item, idx) in summaryResults" :key="idx" 
             class="table-row" :class="{ 'no-win-row': item.isNoWin }">
          <div class="balls-cell">
            <span v-for="(color, j) in item.displayBalls" :key="j" 
                  class="small-ball" :class="color === 'unknown' ? 'ball-unknown' : 'ball-' + color"></span>
          </div>
          <div>{{ item.count }}</div>
          <div>{{ (item.prob * 100).toFixed(3) }}%</div>
          <div class="win-cell" :class="item.win >= totalBet ? 'win-high' : 'win-low'">
            {{ item.isNoWin ? '0' : formatNumber(item.win) }}
          </div>
        </div>

        <div class="table-total" style="font-weight: bold; border-top: 1px solid #666; margin-top: 8px;">
          <div>åˆè®¡</div>
          <div>{{ totalCount }}</div>
          <div>{{ totalProbPercent.toFixed(3) }}%</div>
          <div></div>
        </div>

        <div class="summary-footer">
          <div>æ€»æŠ¼åˆ†: {{ formatNumber(totalBet) }}</div>
          <div>æœŸæœ›åˆ†: <span class="expectation">{{ formatExpectation(expectedWin) }}</span></div>
        </div>
      </div>

      <!-- âœ… å§‹ç»ˆæ˜¾ç¤ºï¼šå„è‰²çƒå¼€å¥–ç»Ÿè®¡ -->
      <div class="color-stats-table">
        <div class="stats-title">å„è‰²çƒå¼€å¥–ç»Ÿè®¡</div>
        <div class="stats-header">
          <div>é¢œè‰²</div>
          <div>æ¬¡æ•°</div>
          <div>å æ¯”</div>
        </div>
        <div v-for="stat in sortedColorStats" :key="stat.color" class="stats-row">
          <div class="color-cell">
            <span class="small-ball" :class="'ball-' + stat.color"></span>
            <span v-if="0" class="color-name">{{ stat.name }}</span>
          </div>
          <div>{{ stat.count }}</div>
          <div>{{ stat.percent.toFixed(2) }}%</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    function generateAllCombinations(colors) {
      const pool = [];
      colors.forEach(color => {
        for (let i = 0; i < 3; i++) pool.push(color);
      });
      const combinations = [];
      const n = pool.length;
      for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
          for (let k = j + 1; k < n; k++) {
            combinations.push([pool[i], pool[j], pool[k]]);
          }
        }
      }
      return combinations;
    }

    new Vue({
      el: '#app',
        data: {
        martingaleResult: null, // å­˜æ”¾å€æŠ•æ¨¡æ‹Ÿç»“æœ
        credit: 1000000,
        win: 0,
        selectedChip: 1000,
        colors: ['gray', 'green', 'blue', 'purple', 'yellow', 'orange'],
        colorNames: {
          gray: 'ç°',
          green: 'ç»¿',
          blue: 'è“',
          purple: 'ç´«',
          yellow: 'é»„',
          orange: 'æ©™'
        },
        bets: {
          gray: 0, green: 0, blue: 0, purple: 0, yellow: 0, orange: 0
        },
        lastBets: {},
        resultBalls: [],
        hasResult: false,
        isSpinning: false,
        allCombinations: [],
        summaryResults: [],
        showSimulation: false,
        machineBalls: [],
        outputBalls: [],
        historyCount: {
          gray: 0, green: 0, blue: 0, purple: 0, yellow: 0, orange: 0
        },
        isAutoMode: false,
        autoTimeout: null,
        simulateCount: 100000,
        simulateMessage: '',
        simulationResult: null, // ğŸ‘ˆ æ–°å¢ï¼šç”¨äºå­˜ç»“æœ
        totalWinScore: 0,   // ğŸŒŸ æ–°å¢ï¼šç´¯è®¡æ€»ä¸­å¥–åˆ†æ•°
        totalBetScore: 0   // ğŸŒŸ æ–°å¢ï¼šç´¯è®¡æ€»æŠ¼æ³¨åˆ†æ•°
      },
      computed: {
        isDisabled() {
          return this.isSpinning || this.isAutoMode;
        },
        totalBet() {
          return Object.values(this.bets).reduce((a, b) => a + b, 0);
        },
        expectedWin() {
          if (this.totalBet === 0) return 0;
          let totalExp = 0;
          for (const combo of this.allCombinations) {
            const count = {};
            this.colors.forEach(c => count[c] = 0);
            combo.forEach(c => count[c]++);
            let win = 0;
            for (const color of this.colors) {
              if (this.bets[color] > 0) {
                const n = count[color];
                let mult = 0;
                if (n === 1) mult = 2;
                else if (n === 2) mult = 3;
                else if (n === 3) mult = 10;
                win += this.bets[color] * mult;
              }
            }
            totalExp += win;
          }
          return totalExp / 816;
        },
        sortedColorStats() {
          const total = Object.values(this.historyCount).reduce((a, b) => a + b, 0) || 1;
          return this.colors.map(color => ({
            color,
            name: this.colorNames[color],
            count: this.historyCount[color],
            percent: (this.historyCount[color] / total) * 100
          })).sort((a, b) => a.count - b.count);
        },
        totalCount() {
          return this.summaryResults.reduce((sum, item) => sum + item.count, 0);
        },
        totalProbPercent() {
          return this.summaryResults.reduce((sum, item) => sum + item.prob * 100, 0);
        }
      },
        methods: {
            updateGlobalTotals(betAmount, winAmount) {
                this.totalBetScore += betAmount;
                this.totalWinScore += winAmount;
            },
            addCredit(amount) {
                this.credit = Number(this.credit) + amount;
            },
        selectChip(amount) {
          if (this.credit <= 0 || this.isSpinning || this.hasResult || this.isAutoMode) return;
          this.selectedChip = amount;
        },
          placeBet(color) {
              this.simulateMessage = ''; // ğŸ‘ˆ æ–°å¢
              this.lastBets = { red: 0, blue: 0, green: 0, yellow: 0, purple: 0, cyan: 0 };
          if (this.hasResult || this.isSpinning || this.credit <= 0 || this.isAutoMode) return;
          if (this.credit >= this.selectedChip) {
            this.$set(this.bets, color, this.bets[color] + this.selectedChip);
            this.credit -= this.selectedChip;
            this.updateSummary();
          }
        },
        clearBets() {
          this.simulateMessage = ''; // ğŸ‘ˆ æ–°å¢
          const refund = this.totalBet;
          this.credit += refund;
          this.bets = {
            gray: 0, green: 0, blue: 0, purple: 0, yellow: 0, orange: 0
          };
          this.showSimulation = false;
        },
        updateSummary() {
          const totalBet = this.totalBet;
          if (totalBet === 0) {
            this.summaryResults = [];
            this.showSimulation = false;
            return;
          }

          const map = new Map();
          let noWinCount = 0;

          for (const combo of this.allCombinations) {
            const count = {};
            this.colors.forEach(c => count[c] = 0);
            combo.forEach(c => count[c]++);

            let win = 0;
            for (const color of this.colors) {
              if (this.bets[color] > 0) {
                const n = count[color];
                let mult = 0;
                if (n === 1) mult = 2;
                else if (n === 2) mult = 3;
                else if (n === 3) mult = 10;
                win += this.bets[color] * mult;
              }
            }

            if (win === 0) {
              noWinCount++;
            } else {
                // 1. å…ˆæ ‡è®°æ¯ä¸ªçƒæ˜¯å¦æŠ•æ³¨ï¼Œå¹¶ä¿ç•™åŸå§‹é¢œè‰²
                const annotated = combo.map(color => ({
                    color: this.bets[color] > 0 ? color : 'unknown',
                    original: color
                }));

                // 2. åˆ†ç¦» unknown å’Œå·²æŠ•æ³¨çƒ
                const unknowns = annotated.filter(item => item.color === 'unknown');
                const betOn = annotated.filter(item => item.color !== 'unknown');

                // 3. å¯¹å·²æŠ•æ³¨çš„çƒï¼šæŒ‰æœ¬ combo ä¸­è¯¥é¢œè‰²å‡ºç°é¢‘æ¬¡é™åºæ’åº
                if (betOn.length > 0) {
                    // ç»Ÿè®¡æœ¬ combo ä¸­å„é¢œè‰²ï¼ˆåŸå§‹ï¼‰çš„é¢‘æ¬¡
                    const freq = {};
                    combo.forEach(c => {
                        freq[c] = (freq[c] || 0) + 1;
                    });

                    // æ’åºï¼šé«˜é¢‘åœ¨å‰ï¼›é¢‘æ¬¡ç›¸åŒåˆ™ä¿æŒåŸå§‹é¡ºåºï¼ˆç¨³å®šï¼‰
                    betOn.sort((a, b) => freq[b.original] - freq[a.original]);
                }

                // 4. åˆå¹¶ï¼šæ’åºåçš„æŠ•æ³¨çƒ + unknown
                const displayBalls = [
                    ...betOn.map(item => item.color),
                    ...unknowns.map(item => item.color)
                ];


              const key = JSON.stringify(displayBalls);

              if (!map.has(key)) {
                map.set(key, {
                  count: 0,
                  win: win,
                  displayBalls: displayBalls,
                  prob: 0
                });
              }
              map.get(key).count++;
            }
          }

          const results = Array.from(map.values()).map(item => ({
            ...item,
            prob: item.count / 816,
            isNoWin: false
          })).sort((a, b) => b.win - a.win);

          if (noWinCount > 0) {
            results.push({
              count: noWinCount,
              prob: noWinCount / 816,
              win: 0,
              displayBalls: ['unknown', 'unknown', 'unknown'],
              isNoWin: true
            });
          }

          this.summaryResults = results;
          this.showSimulation = true;
        },
        async spin() {
          this.isSpinning = true;
          const randomIndex = Math.floor(Math.random() * this.allCombinations.length);
          this.resultBalls = [...this.allCombinations[randomIndex]];

          this.resultBalls.forEach(color => {
            this.historyCount[color]++;
          });

          this.removeBallsFromMachine(this.resultBalls);

          this.outputBalls = [];
          for (let i = 0; i < 3; i++) {
            await this.sleep(500);
            this.outputBalls.push(this.resultBalls[i]);
            }
          let totalBet = this.totalBet;
          let totalWin = 0;
          const count = {};
          this.colors.forEach(c => count[c] = 0);
          this.resultBalls.forEach(c => count[c]++);
          for (const color of this.colors) {
            if (this.bets[color] > 0) {
              const n = count[color];
              let mult = 0;
              if (n === 1) mult = 2;
              else if (n === 2) mult = 3;
              else if (n === 3) mult = 10;
              totalWin += this.bets[color] * mult;
            }
          }
            this.win = totalWin;
            this.updateGlobalTotals(totalBet,totalWin);
          this.hasResult = true;
          this.isSpinning = false;
        },
          removeBallsFromMachine(drawnBalls) {
              // === ç¬¬ä¸€æ­¥ï¼šåŸæ ·æ‰§è¡Œç§»é™¤é€»è¾‘ ===
              const drawnMap = {};
              drawnBalls.forEach(c => {
                  drawnMap[c] = (drawnMap[c] || 0) + 1;
              });

              const newBalls = [];
              const toRemove = { ...drawnMap };

              for (const ball of this.machineBalls) {
                  if (toRemove[ball.color] > 0) {
                      toRemove[ball.color]--;
                  } else {
                      newBalls.push(ball);
                  }
              }

              // === ç¬¬äºŒæ­¥ï¼šå¯¹å‰©ä¸‹çš„çƒé‡æ–°å¸ƒå±€ï¼ˆåº•éƒ¨å †ç§¯ + æ— é‡å ï¼‰===
              this.repackBallsInMachine(newBalls);
          },

          // æ–°å¢ï¼šå°†ä¸€ç»„çƒé‡æ–°æ’å¸ƒåˆ°å®¹å™¨åº•éƒ¨ï¼ˆæ— é‡å ï¼‰
          repackBallsInMachine(balls) {
              const radius = 20; // å¿…é¡»å’Œ CSS ä¸­ .ball-inside çš„åŠå¾„ä¸€è‡´
              const diameter = radius * 2;
              const containerWidth = 200;  // å¿…é¡»å’Œ .gacha-machine çš„ width ä¸€è‡´
              const containerHeight = 160; // å¿…é¡»å’Œ .gacha-machine çš„ height ä¸€è‡´

              const placed = [];

              for (const ball of balls) {
                  let x, y;
                  let placedSuccessfully = false;
                  let attempts = 0;
                  const maxAttempts = 500;

                  while (!placedSuccessfully && attempts < maxAttempts) {
                      attempts++;

                      // éšæœº xï¼ˆä¿è¯ä¸è¶Šç•Œï¼‰
                      x = radius + Math.random() * (containerWidth - diameter);

                      // åˆå§‹ yï¼šè´´åº•
                      y = containerHeight - radius;

                      // æ£€æŸ¥æ˜¯å¦ä¸å·²æ”¾ç½®çš„çƒå†²çª
                      let conflict = false;
                      for (const p of placed) {
                          const dx = x - p.x;
                          const dy = y - p.y;
                          const dist = Math.sqrt(dx * dx + dy * dy);
                          if (dist < diameter - 1e-5) {
                              conflict = true;
                              break;
                          }
                      }

                      if (!conflict) {
                          placed.push({ x, y, color: ball.color });
                          placedSuccessfully = true;
                      }
                      // å¦‚æœå†²çªï¼Œä¸‹ä¸€æ¬¡å¾ªç¯ä¼šå°è¯•æ–°çš„ x
                  }

                  // å¦‚æœå®åœ¨æ”¾ä¸ä¸‹ï¼Œä¹ŸåŠ å…¥ï¼ˆé¿å…ä¸¢å¤±çƒï¼‰
                  if (!placedSuccessfully && balls.length > 0) {
                      // é™çº§ï¼šæ”¾åœ¨åº•éƒ¨éšæœºä½ç½®ï¼ˆå¯èƒ½è½»å¾®é‡å ï¼Œä½†ä¿åº•ï¼‰
                      x = radius + Math.random() * (containerWidth - diameter);
                      y = containerHeight - radius;
                      placed.push({ x, y, color: ball.color });
                  }
              }

              this.machineBalls = placed;
          },
        refillMachine() {
          const allBalls = [];
          this.colors.forEach(color => {
            for (let i = 0; i < 3; i++) {
              allBalls.push({ color });
            }
          });
          this.machineBalls = allBalls.map(ball => ({
            color: ball.color,
            x: 20 + Math.random() * (this.$el.querySelector('.gacha-machine').offsetWidth - 60),
            y: 30 + Math.random() * 100
          }));
        },
          async handleAction() {
              this.simulateMessage = ''; // ğŸ‘ˆ æ–°å¢
          if (this.hasResult) {
            this.lastBets = { ...this.bets };
            this.credit += this.win;
            this.resultBalls = [];
            this.outputBalls = [];
            this.win = 0;
            this.hasResult = false;
            this.bets = { gray:0, green:0, blue:0, purple:0, yellow:0, orange:0 };
            this.refillMachine();
          } else {
            if (Object.values(this.lastBets).some(v => v > 0)) {
              const totalLast = Object.values(this.lastBets).reduce((a,b)=>a+b,0);
              if (this.credit >= totalLast) {
                this.bets = { ...this.lastBets };
                this.credit -= totalLast;
                this.updateSummary();
              } else {
                alert('åˆ†æ•°ä¸è¶³ï¼Œæ— æ³•ä½¿ç”¨ä¸Šå±€æŠ¼æ³¨');
                return;
              }
            }
            await this.spin();
          }
        },
        async autoLoop() {
          if (!this.isAutoMode) return;
          if (this.credit <= 0) {
            this.stopAutoMode();
            return;
          }

          try {
            if (this.totalBet === 0 && Object.values(this.lastBets).some(v => v > 0)) {
              const totalLast = Object.values(this.lastBets).reduce((a,b)=>a+b,0);
              if (this.credit >= totalLast) {
                this.bets = { ...this.lastBets };
                this.credit -= totalLast;
                this.updateSummary();
              } else {
                this.stopAutoMode();
                return;
              }
            }

            if (this.totalBet === 0) {
              this.stopAutoMode();
              return;
            }

            await this.spin();
            await this.sleep(1600);

            this.lastBets = { ...this.bets };
            this.credit += this.win;
            this.win = 0;
            this.hasResult = false;
            this.bets = { gray:0, green:0, blue:0, purple:0, yellow:0, orange:0 };
            this.resultBalls = [];
            this.outputBalls = [];
            this.refillMachine();

            this.autoTimeout = setTimeout(() => this.autoLoop(), 500);
          } catch (e) {
            this.stopAutoMode();
          }
        },
        startAutoMode() {
          if (this.totalBet === 0 && Object.values(this.lastBets).every(v => v === 0)) {
            alert('è¯·å…ˆæŠ¼æ³¨æˆ–å·²æœ‰ä¸Šå±€è®°å½•');
            return;
          }
          this.isAutoMode = true;
          this.autoLoop();
        },
        stopAutoMode() {
          this.isAutoMode = false;
          if (this.autoTimeout) {
            clearTimeout(this.autoTimeout);
            this.autoTimeout = null;
          }
        },
          // åˆ¤æ–­è¯¥é¢œè‰²æ˜¯å¦ä¸­å¥–ï¼ˆæœ‰ 1/2/3 ä¸ªçƒï¼‰
          isWinningColor(color) {
              if (!this.hasResult) return false;
              const count = this.resultBalls.filter(c => c === color).length;
              return count >= 1; // åªè¦æœ‰ â‰¥1 ä¸ªå°±ç®—ä¸­å¥–
          },

          // è¿”å›å€æ•°æ–‡æœ¬ï¼ˆä»…ç”¨äºæ˜¾ç¤ºï¼‰
          multiplierText(color) {
              if (!this.hasResult) return '';
              const count = this.resultBalls.filter(c => c === color).length;
              if (count === 1) return '2x';
              if (count === 2) return '3x';
              if (count === 3) return '10x';
              return ''; // æœªä¸­å¥– â†’ ç©ºå­—ç¬¦ä¸²
          },
        // âœ… å€æ•°æ ·å¼ç±»
        multiplierClass(color) {
          const text = this.multiplierText(color);
          if (text === '0x') return 'multiplier-miss';
          return 'multiplier-hit';
            },
            clearBetsAll() {
                // éå†æ‰€æœ‰é¢œè‰²ï¼Œå°† bets å½’é›¶
                this.colors.forEach(color => {
                    this.$set(this.bets, color, 0);
                });
                // æ€»æŠ¼æ³¨å½’é›¶
                this.totalBet = 0;
            },
        // âœ… æ¨¡æ‹Ÿè¿è¡Œï¼ˆå¸¦ç»“æœåé¦ˆï¼‰
            async runSimulation() {
                if (this.simulateCount <= 0) return;

                const maxRuns = Math.min(this.simulateCount, 100000);
                let runsCompleted = 0;
                const hasBets = this.totalBet > 0;

                // ğŸ”¥ å…³é”®ä¿®å¤ï¼šåæ¨ç”¨æˆ·çœ‹åˆ°çš„â€œåˆå§‹ç‰Œé¢â€
                const logicalInitialCredit = hasBets ? Number(this.credit) + this.totalBet : Number(this.credit);

                if (hasBets && logicalInitialCredit < this.totalBet) {
                    this.simulateMessage = 'åˆ†æ•°ä¸è¶³ï¼Œæ— æ³•å¼€å§‹å¸¦æŠ¼æ³¨çš„æ¨¡æ‹Ÿ';
                    this.simulationResult = null;
                    return;
                }

                const TARGET_DURATION = 5000;
                const UPDATE_INTERVAL = 200;
                const estimatedUpdates = Math.max(1, Math.floor(TARGET_DURATION / UPDATE_INTERVAL));
                const batchSize = Math.max(100, Math.ceil(maxRuns / estimatedUpdates));

                let credit = logicalInitialCredit;
                let totalBetAmount = 0;
                let totalWin = 0;

                const simulateBatch = (start, end) => {
                    for (let i = start; i < end; i++) {
                        if (hasBets && credit < this.totalBet) {
                            runsCompleted = i;
                            return false;
                        }

                        const combo = this.allCombinations[Math.floor(Math.random() * 816)];
                        combo.forEach(color => {
                            this.historyCount[color]++;
                        });

                        if (hasBets) {
                            const count = {};
                            this.colors.forEach(c => count[c] = 0);
                            combo.forEach(c => count[c]++);

                            let win = 0;
                            for (const color of this.colors) {
                                const bet = this.bets[color];
                                if (bet > 0) {
                                    const n = count[color];
                                    if (n === 1) win += bet * 2;
                                    else if (n === 2) win += bet * 3;
                                    else if (n === 3) win += bet * 10;
                                }
                            }

                            totalBetAmount += this.totalBet;
                            totalWin += win;
                            credit = credit - this.totalBet + win;
                            this.updateGlobalTotals(this.totalBet, win);
                        }
                    }
                    runsCompleted = end;
                    return true;
                };

                // è¿”å› Promiseï¼Œå¹¶åœ¨ resolve åè‡ªåŠ¨æ¸…ç©ºæŠ¼æ³¨
                return new Promise((resolve) => {
                    const startTime = Date.now();
                    const runNextBatch = () => {
                        const start = runsCompleted;
                        const end = Math.min(start + batchSize, maxRuns);

                        if (start >= maxRuns || !simulateBatch(start, end)) {
                            this.credit = credit;

                            if (hasBets) {
                                const netProfit = totalWin - totalBetAmount;
                                this.simulationResult = {
                                    status: start >= maxRuns ? 'completed' : 'stopped',
                                    runs: runsCompleted,
                                    totalBetAmount,
                                    totalWin,
                                    netProfit,
                                };
                            } else {
                                this.simulationResult = { status: 'color-only', runs: runsCompleted };
                            }
                            this.simulateMessage = '';
                            resolve(); // ğŸ‘ˆ æ¨¡æ‹Ÿå®Œæˆ
                            return;
                        }

                        this.credit = credit;
                        const elapsed = Date.now() - startTime;
                        const progress = runsCompleted / maxRuns;
                        const expectedElapsed = TARGET_DURATION * progress;
                        const delay = Math.max(0, UPDATE_INTERVAL - (elapsed - expectedElapsed));
                        this.simulateMessage = `æ­£åœ¨æ¨¡æ‹Ÿ... (${runsCompleted}/${maxRuns})`;

                        setTimeout(runNextBatch, delay);
                    };

                    runNextBatch();
                }).then(() => {
                    // âœ… æ‰€æœ‰æ¨¡æ‹Ÿå®Œæˆåï¼Œæ¸…ç©ºæŠ¼æ³¨
                    this.clearBetsAll();
                });
            },
          //å€æŠ•æ³•
          async runMartingaleSimulation() {
                const multiplier = 2;
                const hasBets = this.totalBet > 0;

                if (!hasBets) {
                    this.martingaleResult = { error: 'è¯·å…ˆè®¾ç½®æŠ¼æ³¨' };
                    return;
                }

                let allInCount = 0;

                // åˆå§‹åŒ–æ¨¡æ‹Ÿç”¨ä¿¡ç”¨ï¼ˆä¸ä¿®æ”¹çœŸå® this.credit ç›´åˆ°æ¨¡æ‹Ÿç»“æŸï¼Ÿä½†ä½ è¦æ±‚æ›´æ–°ï¼Œæ‰€ä»¥ç›´æ¥æ“ä½œï¼‰
                // æ³¨æ„ï¼šå¦‚æœä½ å¸Œæœ›æ¨¡æ‹Ÿä¸å½±å“çœŸå®æ•°æ®ï¼Œè¯·å…ˆå¤‡ä»½ã€‚æ­¤å¤„æŒ‰ä½ è¦æ±‚â€œæ›´æ–°åˆ†æ•°â€
                let credit = Number(this.credit);
                const initialBet = this.totalBet;
                let currentBet = initialBet;
                let globalRound = 0;

                // é‡ç½®ç´¯è®¡ç»Ÿè®¡ï¼ˆæˆ–ç´¯åŠ ï¼ŸæŒ‰ä½ å·²æœ‰é€»è¾‘ï¼Œè¿™é‡Œå‡è®¾æ¯æ¬¡æ¨¡æ‹Ÿé‡ç½®ï¼‰
                // å¦‚æœä½ è¦ç´¯åŠ å†å²ï¼Œè¯·ç§»é™¤è¿™ä¸¤è¡Œ
                this.totalBetAmount = 0;
                this.totalWinAmount = 0;

                const completedCycles = [];
                let currentCycleRounds = [];

                let maxCredit = credit;
                let peakCycleIndex = -1;

                while (true) {
                    // ğŸ’¡ å…³é”®ä¿®æ”¹ 1ï¼šèµ„é‡‘ä¸è¶³æ—¶ All-in
                    if (credit <= 0) break;

                    if (credit <= currentBet) {
                        // å…¨æŠ¼å‰©ä½™
                        currentBet = credit;
                        allInCount++; // âœ… è®¡æ•° +1
                    }

                    globalRound++;

                    // å¼€å¥–
                    const combo = this.allCombinations[Math.floor(Math.random() * 816)];

                    // âœ… æ›´æ–°é¢œè‰²ç»Ÿè®¡
                    combo.forEach(color => {
                        this.historyCount[color] = (this.historyCount[color] || 0) + 1;
                    });

                    // è®¡ç®—ä¸­å¥–
                    let win = 0;
                    if (this.totalBet > 0) {
                        const count = {};
                        this.colors.forEach(c => count[c] = 0);
                        combo.forEach(c => count[c]++);

                        for (const color of this.colors) {
                            const ratio = this.bets[color] / this.totalBet;
                            const actualBet = ratio * currentBet;
                            const n = count[color];
                            let mult = 0;
                            if (n === 1) mult = 2;
                            else if (n === 2) mult = 3;
                            else if (n === 3) mult = 10;
                            win += actualBet * mult;
                        }
                    }

                    // âœ… æ›´æ–°å…¨å±€ç´¯è®¡
                    this.totalBetAmount += currentBet;
                    this.totalWinAmount += win;

                    const creditBefore = credit;
                    credit = credit - currentBet + win;

                    // âœ… å®æ—¶æ›´æ–° this.creditï¼ˆæŒ‰ä½ è¦æ±‚ï¼‰
                    this.credit = credit;

                    // æ›´æ–°å³°å€¼
                    if (credit > maxCredit) {
                        maxCredit = credit;
                        // æš‚ä¸è®¾ peakCycleIndexï¼Œç­‰å‘¨æœŸç»“æŸå†åˆ¤æ–­
                    }

                    currentCycleRounds.push({
                        round: globalRound,
                        bet: currentBet,
                        win,
                        creditAfter: credit
                    });

                    // åˆ¤æ–­æœ¬å±€æ˜¯å¦ç›ˆåˆ©ï¼ˆç”¨äºç»“æŸå‘¨æœŸï¼‰
                    const isProfitable = win >= currentBet;

                    if (isProfitable) {
                        // å‘¨æœŸæˆåŠŸç»“æŸ
                        const totalBet = currentCycleRounds.reduce((s, r) => s + r.bet, 0);
                        const totalWin = win; // åªæœ€åä¸€æŠŠæœ‰æ”¶ç›Š
                        const netProfit = totalWin - totalBet;

                        const cycleEndCredit = credit;
                        completedCycles.push({
                            totalBet,
                            totalWin,
                            netProfit,
                            creditAfter: cycleEndCredit,
                            endedAtRound: globalRound
                        });

                        // æ£€æŸ¥å³°å€¼æ˜¯å¦åœ¨æ­¤å‘¨æœŸ
                        if (cycleEndCredit >= maxCredit) {
                            maxCredit = cycleEndCredit;
                            peakCycleIndex = completedCycles.length - 1;
                        }

                        // é‡ç½®ä¸‹ä¸€è½®
                        currentCycleRounds = [];
                        currentBet = initialBet;
                    } else {
                        // ç»§ç»­å€æŠ•
                        currentBet *= multiplier;
                    }

                    // å¦‚æœä½™é¢ä¸º 0ï¼Œå¼ºåˆ¶é€€å‡º
                    if (credit <= 0) break;
                }

                // æ„é€ æœªå®Œæˆå‘¨æœŸï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                let incompleteCycle = null;
                const failedChain = [...currentCycleRounds]; // ä¿ç•™åŸå§‹é“¾

                if (failedChain.length > 0) {
                    const totalBet = failedChain.reduce((s, r) => s + r.bet, 0);
                    const totalWin = failedChain.reduce((s, r) => s + r.win, 0);
                    const netProfit = totalWin - totalBet;
                    const finalCredit = failedChain[failedChain.length - 1]?.creditAfter || 0;

                    incompleteCycle = {
                        totalBet,
                        totalWin,
                        netProfit,
                        creditAfter: finalCredit,
                        isIncomplete: true
                    };

                    // æ£€æŸ¥å¤±è´¥é“¾ä¸­æ˜¯å¦æœ‰æ›´é«˜ä½™é¢ï¼ˆç½•è§ï¼Œä½†å¤„ç†ï¼‰
                    const chainMax = Math.max(...failedChain.map(r => r.creditAfter));
                    if (chainMax > maxCredit) {
                        maxCredit = chainMax;
                        peakCycleIndex = -2;
                    }
                }

                // æ±‡æ€»
                const totalBetAmount = completedCycles.reduce((s, c) => s + c.totalBet, 0) + (incompleteCycle?.totalBet || 0);
                const totalWin = completedCycles.reduce((s, c) => s + c.totalWin, 0) + (incompleteCycle?.totalWin || 0);
                const netProfit = totalWin - totalBetAmount - this.totalBet;


                this.martingaleResult = {
                    completedCycles,
                    incompleteCycle,
                    failedChain, // ç”¨äºå±•å¼€è¯¦æƒ…
                    finalCredit: credit,
                    maxCredit,
                    peakCycleIndex,
                    summary: { totalBetAmount, totalWin, netProfit },
                    allInCount// âœ… æ–°å¢å­—æ®µï¼šå­¤æ³¨ä¸€æ·æ¬¡æ•°
                };
              this.clearBetsAll();
            },
          formatNumber(num) {
              if (num === 0) return '0';

              const isNegative = num < 0;
              const absNum = Math.abs(num);

              let result;
              if (absNum >= 1000000) {
                  result = (absNum / 1000000).toFixed(1) + 'M';
              } else if (absNum >= 1000) {
                  // ä½¿ç”¨ toFixed(0) æˆ– Math.floorï¼Œæ ¹æ®éœ€æ±‚
                  result = Math.floor(absNum / 1000) + 'K';
              } else {
                  result = absNum.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
              }

              return isNegative ? '-' + result : result;
          },
        formatExpectation(num) {
          if (num >= 1000000) return (num / 1000000).toFixed(2) + 'M';
          if (num >= 1000) return (num / 1000).toFixed(2) + 'K';
          return num.toFixed(2);
        },
        sleep(ms) {
          return new Promise(resolve => setTimeout(resolve, ms));
        }
      },
      mounted() {
        this.allCombinations = generateAllCombinations(this.colors);
        this.refillMachine();
      }
    });
  </script>
</body>
</html>
